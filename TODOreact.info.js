//! npm install react-router-dom
// * npm create vite@latest client -- --template react-ts
// * cd client
// * npm i 
// * npm run dev

// todo Библиотека VS фреймворк
// ? Библиотека
// * более гибкая
// * позволяет брать из себя небольшие куски и использовать
// ? Фреймворк
// * жёсткие правила, которым нужно следовать
// * не позволяет брать из себя небольшие куски

// todo React-компонент & React-элемент
// * React-компонент — функция или класс для создания React-элемента.
// * React-элемент — объект с описанием того, что React должен отрисовать в DOM-дереве.

// ! if...else в return компонента JSX не работает!

// todo React.Fragment === <></> - обёртка нескольких элементов в один, которого нет в DOM

// todo props (properties) (свойства)
// * Объект со свойствами компонента, передаваемый из родительского компонента
// ? правила пропсов:
// * передаются от родителя к детям и не передаются обратно
// * ф-ии можно передать пропсом вниз и вызывать внизу
// * пропсы нельзя изменить в получаемом их компоненте


//! COUNT

//! RFC (react function component) - создаем реактовский компонент
// * экспортируем его по дефолту
// * импортируем в app.tsx

//? импортируем из реакта useState - это ХУК
import { useState } from 'react';

//? (из негого методом деструктуризации вытаскиваем само состояние и функцию, которая может влиять на это состояние)
const [count, setCount] = useState(0, 'начальное состояние');

//? вешаем на кнопки события (onClick)
<button type="button" onClick={ВОТ СЮДА!}>

//? пишем функции, которые будут работать в онклике - ХЕНДЛЕРЫ 
//? это функция, которая вызывает дрругую функцию (setCount из useState) в которой будет колбек с решающей функцией
const decrementHandler = () => {
    setCount((prev) => prev - 1);
  };


//! FORM

//! RFC (react function component) - создаем реактовский компонент
// * экспортируем его по дефолту
// * импортируем в app.tsx

//?  useState
const [inputs, setInputs] = useState({ title: "", text: "" });

//? рисуем форму с инпутами

//? вешаем на инпуты onChange, даем имена инпутам + велью
<input onChange={changeHandler} name="text" value={inputs.text} />


//? хендлер для ввода + типизируем ивент
const changeHandler = (e: ChangeEvent<HTMLInputElement>): void => {
    setInputs((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };


//? пишем хендлер на кнопку + сщздаем кнопку
const submitHandler = async (): Promise<void> => {
    const res = await axios.post<Todo>("http://localhost:3000/api", inputs);
    setTodos((prev) => [...prev, res.data]);
    setInputs({ title: "", text: "" });
  };

  //! Новый элемент для создания тудушек
  //? пишем хук useState в app.tsx
  const [todos, setTodos] = useState<Todos>([]);

    //? пишем хук useEffect - занимается жизненным циклом нашего компонента в app.tsx
    useEffect(() => {
    axios.get<Todos>('http://localhost:3000/api').then((res) => {
      console.log(res)
      setTodos(res.data)
    })
  }, []) // changeSome 0 + 1 + 1

  //! dependencies array (массив зависимостей)
  //! [] - componentDidMount
  //! [count] - componentDidUpdate
  //! componentWillUnmount - return () => {}

  /*
  Жизненный цикл компонента в React описывает различные стадии, через которые проходит компонент от его создания до удаления. Эти стадии включают в себя создание (mounting), обновление (updating) и удаление (unmounting). React предоставляет методы жизненного цикла и хуки, которые позволяют вам выполнять действия на различных стадиях жизненного цикла компонента.

Основные стадии жизненного цикла:
Создание (Mounting):

Это момент, когда компонент впервые добавляется в DOM.
Основные методы жизненного цикла на этом этапе:
constructor(): Инициализация состояния и привязка методов.
componentDidMount(): Вызывается сразу после того, как компонент был добавлен в DOM. Здесь можно выполнять действия, требующие доступа к DOM (например, сетевые запросы).
Обновление (Updating):

Происходит, когда компонент получает новые пропсы или изменяется его состояние.
Основные методы жизненного цикла на этом этапе:
componentDidUpdate(prevProps, prevState): Вызывается сразу после обновления компонента. Здесь можно выполнять действия на основе предыдущих пропсов или состояния.
Удаление (Unmounting):

Это момент, когда компонент удаляется из DOM.
Основной метод жизненного цикла на этом этапе:
componentWillUnmount(): Вызывается перед удалением компонента из DOM. Здесь можно выполнять действия по очистке (например, очистка таймеров или отмена сетевых запросов).
  
  */
  
  

  //? устанавливаем библиотеку axios (проверяем в package.json)

  //? типизируем туду в app.tsx
  export type Todo ={
  id: number;
  title: string;
  text: string;
  isCompleted: boolean;
  createdAt: Date;
  updatedAt: Date;
}

//? типизируем тодос все
export type Todos = Todo[]; // === Array<Todo>

 //? передаем пропсом функцию для получения туду
 <Form setTodos={setTodos} />

//! в форме
 //? в форме, пишем хендлер для записи в БД
 const submitHandler = async (): Promise<void> => {
    const res = await axios.post<Todo>("http://localhost:3000/api", inputs);
    setTodos((prev) => [...prev, res.data]);
    setInputs({ title: "", text: "" });
  };
   
   //? хендлер на кнопку
   <button type="button" onClick={submitHandler} />

   //? перинимаем пропсами функцию и типизируем ее
   export default function Form({ 
  setTodos,
}: {
  setTodos: Dispatch<SetStateAction<Todos>>;
}): JSX.Element { }

//? диспатч достаем из реакта

//? отрисовываем в элементе туду


//!
{/* useState нужен для управления состоянием компонента, чтобы мы могли изменять конкретные элементы
 и хранить данные внутри компонента.
useEffect нужен для выполнения побочных эффектов (например, сетевые запросы, обновление заголовка,
 настройка таймеров) и управления тем, что происходит при монтировании, обновлении и размонтировании компонента. */}

 //! setTodos: Функция для обновления состояния списка задач.
 //! Form: Использует setTodos для добавления новой задачи.
//! List: Получает задачи для отображения и функцию setTodos для их обновления.
//! Таким образом, setTodos играет ключевую роль в управлении состоянием задач в вашем приложении, обеспечивая их получение, добавление и обновление.

//? memo предотвращает ненужные рендеры компонентов при неизменных пропсах.
//? useMemo предотвращает ненужные вычисления значений внутри компонента при неизменных зависимостях.